/*
 * generated by Xtext 2.30.0
 */
package verification.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import verification.services.VerificationGrammarAccess;
import verification.verification.Alter;
import verification.verification.Assignment;
import verification.verification.Automaton;
import verification.verification.Condition;
import verification.verification.Event;
import verification.verification.Global;
import verification.verification.Local;
import verification.verification.Location;
import verification.verification.Model;
import verification.verification.State;
import verification.verification.Transition;
import verification.verification.VariableReference;
import verification.verification.VerificationPackage;

@SuppressWarnings("all")
public class VerificationSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private VerificationGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == VerificationPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case VerificationPackage.ALTER:
				sequence_Alter(context, (Alter) semanticObject); 
				return; 
			case VerificationPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case VerificationPackage.AUTOMATON:
				sequence_Automaton(context, (Automaton) semanticObject); 
				return; 
			case VerificationPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case VerificationPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case VerificationPackage.GLOBAL:
				sequence_Global(context, (Global) semanticObject); 
				return; 
			case VerificationPackage.LOCAL:
				sequence_Local(context, (Local) semanticObject); 
				return; 
			case VerificationPackage.LOCATION:
				sequence_Location(context, (Location) semanticObject); 
				return; 
			case VerificationPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case VerificationPackage.STATE:
				sequence_State(context, (State) semanticObject); 
				return; 
			case VerificationPackage.TRANSITION:
				sequence_Transition(context, (Transition) semanticObject); 
				return; 
			case VerificationPackage.VARIABLE_REFERENCE:
				sequence_VariableReference(context, (VariableReference) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Alter returns Alter
	 *
	 * Constraint:
	 *     (state=[State|ID] locals+=Local* transitions+=Transition*)
	 * </pre>
	 */
	protected void sequence_Alter(ISerializationContext context, Alter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (currentVar=VariableReference value=Value)
	 * </pre>
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VerificationPackage.Literals.ASSIGNMENT__CURRENT_VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VerificationPackage.Literals.ASSIGNMENT__CURRENT_VAR));
			if (transientValues.isValueTransient(semanticObject, VerificationPackage.Literals.ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VerificationPackage.Literals.ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getCurrentVarVariableReferenceParserRuleCall_0_0(), semanticObject.getCurrentVar());
		feeder.accept(grammarAccess.getAssignmentAccess().getValueValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Automaton returns Automaton
	 *
	 * Constraint:
	 *     (name=ID location+=Location*)
	 * </pre>
	 */
	protected void sequence_Automaton(ISerializationContext context, Automaton semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (left=VariableReference operator=ComparisonOperator right=Value)
	 * </pre>
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VerificationPackage.Literals.CONDITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VerificationPackage.Literals.CONDITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, VerificationPackage.Literals.CONDITION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VerificationPackage.Literals.CONDITION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, VerificationPackage.Literals.CONDITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VerificationPackage.Literals.CONDITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAccess().getLeftVariableReferenceParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConditionAccess().getOperatorComparisonOperatorEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getConditionAccess().getRightValueParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Event returns Event
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Event(ISerializationContext context, Event semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VerificationPackage.Literals.EVENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VerificationPackage.Literals.EVENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEventAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Global returns Global
	 *     Variable returns Global
	 *
	 * Constraint:
	 *     (name=ID type=DataType value=STRING?)
	 * </pre>
	 */
	protected void sequence_Global(ISerializationContext context, Global semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Local returns Local
	 *     Variable returns Local
	 *
	 * Constraint:
	 *     (name=ID type=DataType value=STRING?)
	 * </pre>
	 */
	protected void sequence_Local(ISerializationContext context, Local semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Location returns Location
	 *
	 * Constraint:
	 *     state=[State|ID]
	 * </pre>
	 */
	protected void sequence_Location(ISerializationContext context, Location semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VerificationPackage.Literals.LOCATION__STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VerificationPackage.Literals.LOCATION__STATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocationAccess().getStateStateIDTerminalRuleCall_0_1(), semanticObject.eGet(VerificationPackage.Literals.LOCATION__STATE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=ID globals+=Global* events+=Event* (states+=State | alters+=Alter)* automaton+=Automaton*)
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     State returns State
	 *
	 * Constraint:
	 *     (name=ID locals+=Local* transitions+=Transition*)
	 * </pre>
	 */
	protected void sequence_State(ISerializationContext context, State semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Transition returns Transition
	 *
	 * Constraint:
	 *     (event=[Event|ID] state=[State|ID] condition=Condition? assignment=Assignment?)
	 * </pre>
	 */
	protected void sequence_Transition(ISerializationContext context, Transition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableReference returns VariableReference
	 *
	 * Constraint:
	 *     variable=[Variable|ID]
	 * </pre>
	 */
	protected void sequence_VariableReference(ISerializationContext context, VariableReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VerificationPackage.Literals.VARIABLE_REFERENCE__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VerificationPackage.Literals.VARIABLE_REFERENCE__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableReferenceAccess().getVariableVariableIDTerminalRuleCall_0_1(), semanticObject.eGet(VerificationPackage.Literals.VARIABLE_REFERENCE__VARIABLE, false));
		feeder.finish();
	}
	
	
}
