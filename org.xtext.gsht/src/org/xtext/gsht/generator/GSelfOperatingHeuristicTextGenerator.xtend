/*
 * generated by Xtext 2.30.0
 */
package org.xtext.gsht.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.gsht.gSelfOperatingHeuristicText.Global
import org.xtext.gsht.gSelfOperatingHeuristicText.Model
import org.xtext.gsht.gSelfOperatingHeuristicText.State
import java.util.ArrayList
import java.util.HashMap
import java.util.List

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class GSelfOperatingHeuristicTextGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		resource.allContents.filter(typeof(Model)).forEach[it.generateFile(fsa)]
		resource.allContents.filter(typeof(Model)).forEach[it.generateUppaal(fsa)]
	}
		
	def void generateFile(Model model, IFileSystemAccess2 fsa){
		fsa.generateFile('gsht/'+model.name+'.java', model.generate)
	}
	
	def generate(Model model){
		'''
		/* Autogenerated Code */
		package gsht;

		import org.State;
		import org.Transition;
		import java.util.ArrayList;
		import java.util.HashMap;
		
		
		public class «model.name» {
			
			private State currentState;
			private HashMap<String, Object> globalProps = new HashMap<>() {
				{
				«FOR p : model.globals»
				put("«p.name»", «p.value»);
				«ENDFOR»
				}
			};
			
			private ArrayList<String> events = new ArrayList<>() {
				{
					«FOR event : model.events»
					add("«event.name»");
					«ENDFOR»
				}
			};
			
			private HashMap<String, State> states = new HashMap<>() {
				{
					«model.generateState()»
				}
			};
			
			public «model.name»() {
				«FOR s : model.states»
				«IF s.init»
				currentState = states.get("«s.name»");
				«ENDIF»
				«ENDFOR»
			}
			
			public HashMap<String, Object> getGlobalProps() {
				return globalProps;
			}
			
			public void setGlobalProps(HashMap<String, Object> globalProps) {
				this.globalProps = globalProps;
			}
			
			public void setGlobalProp(String key, Object value) {
				this.globalProps.put(key, value);
			}
			
			public void processEvent(String event) {
				printEvent(event);
				currentState.setGlobalProps(new HashMap<>(globalProps));
				String nextStateName = currentState.onEvent(event);
				if (currentState.getGlobalPropsSize() > 0) {
					this.globalProps = new HashMap<>(currentState.returnGlobalProps());
				}
				currentState = states.get(nextStateName);
				printGlobalProps();
				printCurrentState(currentState);
			};

			private void printEvent(String event) {
				System.out.println();
				System.out.println("==================================");
				System.out.println(String.format("Processing event: '%s'...", event));
				System.out.println("==================================");
				System.out.println();
			}

			private void printGlobalProps() {
				System.out.println("Global props:");
				globalProps.entrySet().forEach(entry -> {
					System.out.println(String.format("%s\t%s", entry.getKey(), entry.getValue().toString()));
				});
				System.out.println();
			}

			private void printCurrentState(State state) {
				System.out.println(String.format("Current state: %s", state.getName()));
				state.printState();
			}
			public State getCurrentState() {
			    return currentState;
			}
		}
		'''
	}
		
	def generateState(Model model){
		'''
		«FOR state : model.states»
		put("«state.name»", new State() {
			{
				setName("«state.name»");
				«IF state.locals.length > 0»
				«FOR p : state.locals»
				addProp("«p.name»", «p.value»);
				«ENDFOR»
				«ENDIF»
				«state.generateTransition()»
			}
		});
		«ENDFOR»
		'''
	}
	
	def generateTransition(State state) {
		'''
		«IF state.transitions.length > 0»
		«FOR t : state.transitions»
		addTransition("«t.event.name»", new Transition() {
			{
				setEvent("«t.event.name»");
				setToState("«t.state.name»");
				«IF t.condition != null»
				setHasCondition(true);
				«IF t.condition.left.variable instanceof Global»
				setEvaluatedValueName("«t.condition.left.variable.name»", true);
				«ELSE »
				setEvaluatedValueName("«t.condition.left.variable.name»");
				«ENDIF»
				setOperatorType("«t.condition.operator»");
				«IF t.condition.right == "TRUE"»
				setOperatingValue(true);
				«ELSEIF t.condition.right == "FALSE"»
				setOperatingValue(false);
				«ELSE»
				setOperatingValue(«t.condition.right»);
				«ENDIF»
				«ENDIF»
				«IF t.assignment != null»
					«IF t.assignment.currentVar.variable instanceof Global»
					createAssignment("«t.assignment.currentVar.variable.name»", «t.assignment.value», true);
					«ELSE»
					createAssignment("«t.assignment.currentVar.variable.name»", «t.assignment.value», false);
					«ENDIF»
				«ENDIF»
			}
		});
		«ENDFOR»
		«ENDIF»
		'''
	}
	
	def void generateUppaal(Model model, IFileSystemAccess2 fsa){
		var automata = new HashMap<String, List<State>>();/*checks how many templates should be made */
		if(!model.automaton.isEmpty()){
			for (a : model.automaton){automata.put(a.name, a.states)}			
		}else{
			automata.put(model.name, model.states)
		}
		
		var CharSequence context = '''
		«var globals = new ArrayList() /*adding global variables */»
		«
		for (global: model.globals){
			var type = global.type + ""
			if(type != "String"){
				if(type == "boolean"){
					globals.add("bool " + global.name + ";")
				}else{
					globals.add(type + " " + global.name + ";")
				}
				
			}
		}
		»
		«FOR global: globals»
		«global»
		«ENDFOR»
		
		«FOR automaton: automata.keySet()»
		«var channels = new ArrayList()»
		«var edges = new ArrayList()»
		«var locations = automata.get(automaton)»
		process «automaton»(	
		« /*saving all events into channels */
		for(location : automata.get(automaton)){
			for(transition: location.transitions){
				channels.add(transition.event.name)
			}
		}
		»
		«FOR chan: channels SEPARATOR ','»
		chan &«chan»
		«ENDFOR»
		){
			«var propsMap = new HashMap<String, String>()»
			«for(location : locations){
				for(prop : location.locals){
					var type = prop.type + ""
					if(type != "String"){
						if(type == "boolean"){
							propsMap.put(prop.name, "bool " + prop.name + ";")
						}else {
							propsMap.put(prop.name, type + " " + prop.name + ";")
						}
					}
					
				}
			}»
			«var props = propsMap.values().toArray()»
			«FOR prop : props»
			«prop»
			«ENDFOR»
			
			state
				«FOR location: locations SEPARATOR ',' AFTER ';'»
					«location.name»
				«ENDFOR»
				
				init «locations.get(0).name»;
				
			trans
				«FOR location: locations»
				«
				if(!location.transitions.isEmpty()){
					for(transition : location.transitions){
						var edge = location.name + " -> " + transition.state.name + "{"
						var condition = transition.condition
						if(condition !== null){edge += " guard " + condition.left.variable.name + condition.operator + condition.right.toLowerCase() +";"}
						edge += " sync " + transition.event.name + "!;"
						/*assign */
						var assignment = transition.assignment;
						if(assignment !== null){
							var type = assignment.currentVar.variable.type + "";
							if(!type.contains("String")){
								edge += " assign " + assignment.currentVar.variable.name + " = " + assignment.value.toLowerCase() + ";"
							}
						}
						
						edges.add(edge += " }")
					}	
				}
				»		
				«ENDFOR»
				«FOR edge: edges SEPARATOR ',' AFTER ';'»
				«edge»
				«ENDFOR»
				}
		«ENDFOR»
		
		«FOR event: model.events»
		chan «event.name»;
		«ENDFOR»
		
		«FOR automaton: automata.keySet()»
		«var channels = new ArrayList()»
		« /*saving all events into channels */
			for(location:automata.get(automaton)){
				for(transition: location.transitions){
					channels.add(transition.event.name)
				}
			}
		»
		«automaton»1 = «automaton»(
		«FOR chan: channels SEPARATOR ','»
		«chan» 
		«ENDFOR»
		);
		«ENDFOR»
		
		«FOR automaton: model.automaton»
		system «automaton.name»1;
		«ENDFOR»
		'''
		
		fsa.generateFile(model+'.xta', context)
		
		
	}
}
